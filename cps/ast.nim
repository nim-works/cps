import std/macros

# Parts of this module:
# * distinct types representing specific variants of Nim AST (`NimNode`)
# * procs used to query, transform, etc on the above as conveniences
# * distinct types representing normalized/transformed variants of distinct AST
# * procs use to query, transform, etc on the normalized AST as conveniences
#
# Why each part:
# * AST types        - make proc signatures in CPS code more intentional
# * AST procs        - contain the gotchas and peculiarities of Nim AST
# * Normalized types - codify the pre/post conditions of CPS code
# * Normalized procs - ensure invariants by centralizing the AST operations
#
# TODO
# * move away from assert where it makes sense
# * make templates to ease some of the type type boilerplate

func isEmpty*(n: NimNode): bool =
  ## `true` if the node `n` is Empty
  result = not n.isNil and n.kind == nnkEmpty

# These are the regular AST types, but specialized
type
  VarLetSection* = distinct NimNode
    ## a var or let section with one or more declarations in the section
  VarTupleOrIdentDefs = distinct NimNode
    ## Var and Let Sections can have VarTuple (destructuring) or IdentDefs
  IdentDefs* = distinct NimNode
    ## one or more identifiers and their definition
  VarTuple* = distinct NimNode
    ## typically a destructuring tuple
  AnyVarTupleOrIdentDefs = VarTupleOrIdentDefs | VarTuple | IdentDefs
    ## useful when we want a sub-type like relation

  StmtList* = distinct NimNode

  # HiddenAddr = distinct NimNode
  # HiddenDeref = distinct NimNode
  HiddenAddrDeref* = distinct NimNode

  Call* = distinct NimNode
  Conv* = distinct NimNode
    ## nnkConv node, only valid when generated by sem
  HiddenCallConv* = distinct NimNode
    ## nnkHiddenCallConv

  CallLike* = Call

  ReturnStmt* = distinct NimNode

  # Handling sub-sets of nodes and their invalid variety
  DistinctNimNode = AnyVarTupleOrIdentDefs | VarLetSection | ReturnStmt | HiddenAddrDeref

  Maybe*[T: DistinctNimNode] = object
    n*: T

  # Enums representing smaller sub-sets
  VarLetSectionChildKind* {.pure.} = enum
    nnkIdentDefs = nnkIdentDefs,
    nnkVarTuple = nnkVarTuple,
    invalid

  # Utility Types
  Mapper*[T = NimNode] = proc(n: NimNode): T

# fn-Error

proc errorAst*(s: string, info: NimNode = nil): NimNode =
  ## produce {.error: s.} in order to embed errors in the ast
  ##
  ## optionally take a node to set the error line information
  result = nnkPragma.newTree:
    ident"error".newColonExpr: newLit s
  if not info.isNil:
    result[0].copyLineInfo info

proc errorAst*(n: NimNode; s = "creepy ast"): NimNode {.inline.} =
  ## embed an error with a message, the line info is copied from the node
  ## too
  # TODO: we might no longer need this now that the other version can
  #       get the line info
  errorAst(s & ":\n" & treeRepr(n) & "\n", n)

proc errorAst*[T:DistinctNimNode](n: T; s = "creepy ast"): NimNode {.inline.} =
  errorAst(n.NimNode, s)

proc errorAst*[T:DistinctNimNode](n: Maybe[T]; s = "creepy ast"): NimNode {.inline.} =
  errorAst(n.n.NimNode, s)

# fn-Maybe

func baseKind*(n: Maybe): NimNodeKind {.inline.} =
  n.n.NimNode.kind

# proc mapAs*[T:DistinctNode](n: NimNode, _: typedesc[T], mapper: Mapper[T]): Maybe[T] =
#   when T is HiddenCallConv:
#     if n.kind == nnkHiddenCallConv:
#       result = mapper(n.HiddenAddrDeref)

# fn-stmtList

proc newStmtList2*(): StmtList {.inline.} =
  ## creates a new `nnkStmtList`, but
  newStmtList().StmtList

proc add*(n: StmtList, c: NimNode): StmtList {.inline, discardable.} =
  ## add to the StmtList and return it for chaining
  n.NimNode.add(c).StmtList

proc add*(n: StmtList, c: DistinctNimNode): StmtList {.inline, discardable.} =
  ## add to the StmtList and return it for chaining
  n.NimNode.add(c.NimNode).StmtList

# fn-IdentDefs

func hasNoExplicitInitValue*(i: IdentDefs): bool {.inline.} =
  i.NimNode.len == 2

func hasNoExplicitType*(i: IdentDefs): bool {.inline.} =
  i.NimNode[1].isEmpty

proc ensureExplicitType*(i: IdentDefs) {.inline.} =
  ## add an explicit type symbol
  if i.hasNoExplicitType:
    i.NimNode[1] = getTypeInst i.NimNode[2]

proc definition*(i: IdentDefs): NimNode {.inline.} =
  i.NimNode[2]

proc `definition=`*(i: IdentDefs, v: NimNode) {.inline.} =
  i.NimNode[2] = v

proc get*(n: Maybe[IdentDefs]): IdentDefs {.inline.} =
  doAssert n.baseKind == nnkIdentDefs
  n.n

proc asIdentDefs*(n: NimNode): Maybe[IdentDefs] {.inline.} =
  result = Maybe[IdentDefs](n: n.IdentDefs)

# fn-VarTupleOrIdentDefs

func kind*(n: Maybe[VarTupleOrIdentDefs]): VarLetSectionChildKind {.inline.} =
  case n.baseKind
  of nnkVarTuple: VarletSectionChildKind.nnkVarTuple
  of nnkIdentDefs: VarLetSectionChildKind.nnkIdentDefs
  else: VarLetSectionChildKind.invalid

func asVarTupleOrIdentDefs(n: NimNode): Maybe[VarTupleOrIdentDefs] {.inline.} =
  result = Maybe[VarTupleOrIdentDefs](n: n.VarTupleOrIdentDefs)

func get*(n: Maybe[VarTupleOrIdentDefs]): VarTupleOrIdentDefs {.inline.} =
  doAssert n.baseKind in {nnkVarTuple, nnkIdentDefs}
  result = n.n

func get*[T: VarTuple | IdentDefs](n: Maybe[VarTupleOrIdentDefs], _: typedesc[T]): T {.inline.} =
  doAssert n.baseKind == (when T is IdentDefs: nnkIdentDefs else: nnkVarTuple)
  result = n.n.T

# fn-VarLetSection

func baseKind*(n: VarLetSection): NimNodeKind {.inline.} =
  n.NimNode.kind

iterator items*(n: VarLetSection): Maybe[VarTupleOrIdentDefs] {.inline.} =
  for child in n.NimNode.items():
    yield Maybe(child.asVarTupleOrIdentDefs)

proc add*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection {.inline.} =
  n.NimNode.add(c.NimNode)
  n

proc newSingleChildSection*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection =
  result = newNimNode(n.baseKind, n.NimNode).VarLetSection
  return result.add(c)

proc asVarLetSection*(n: NimNode): VarLetSection {.inline.} =
  # XXX: move away from assert, maybe via Maybe
  doAssert n.kind in {nnkVarSection, nnkLetSection}
  result = n.VarLetSection

# fn-HiddenAddrDeref

func target*(n: HiddenAddrDeref): NimNode {.inline.} =
  n.NimNode[0]

func get*(n: Maybe[HiddenAddrDeref]): HiddenAddrDeref {.inline.} =
  doAssert n.baseKind in {nnkHiddenAddr, nnkHiddenDeref}
  result = n.n

func asHiddenAddrDeref*(n: NimNode): Maybe[HiddenAddrDeref] {.inline.} =
  result = Maybe[HiddenAddrDeref](n: n.HiddenAddrDeref)

# fn-Call

proc newCall*(infoOf: NimNode, name: NimNode, arg: NimNode): Call {.inline.} =
  ## Create a new single arugment Call (nnkCall)
  result = newNimNode(nnkCall, infoOf).Call
  result.NimNode.add name
  result.NimNode.add arg

# fn-Conv

proc name*(c: Conv): NimNode {.inline.} =
  c.NimNode[0]

proc arg*(c: Conv): NimNode {.inline.} =
  c.NimNode[1]

proc asConv*(n: NimNode): Conv {.inline.} =
  assert n.kind == nnkConv
  result = n.Conv

# fn-HiddenCallConv

proc toCall(n: HiddenCallConv, mapper: Mapper): Call {.inline.} =
  ## unwraps the hidden conversion, mapping the children over
  result = nnkCall.newNimNode(n.NimNode).Call
  for child in n.NimNode.items:
    result.NimNode.add:
      mapper(child)

# fn-Calllike

proc isNonNullary*(n: CallLike): bool {.inline.} =
  ## Takes at least one argument
  n.NimNode.len > 1

proc hasHiddenStdConv*(n: CallLike): bool {.inline.} =
  ## Has an immediate child with a standard conversion
  not n.NimNode.findChild(it.kind == nnkHiddenStdConv).isNil

# fn-ReturnStmt

proc copy*(n: ReturnStmt): ReturnStmt {.inline.} =
  copyNimNode(n.NimNode).ReturnStmt

proc add*(n: ReturnStmt, c: NimNode): ReturnStmt {.inline, discardable.} =
  ## XXX: this is bad and should be removed/reworked
  n.NimNode.add(c).ReturnStmt

proc isAssignment*(n: ReturnStmt): bool {.inline.} =
  n.NimNode[0].kind == nnkAsgn

proc expression*(n: ReturnStmt): NimNode {.inline.} =
  n.NimNode[0]

proc asReturnStmt*(n: NimNode): ReturnStmt {.inline.} =
  assert n.kind == nnkReturnStmt
  result = n.ReturnStmt
