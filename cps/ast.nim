import std/macros

# Parts of this module:
# * distinct types representing specific variants of Nim AST (`NimNode`)
# * procs used to query, transform, etc on the above as conveniences
# * distinct types representing normalized/transformed variants of distinct AST
# * procs use to query, transform, etc on the normalized AST as conveniences
#
# Why each part:
# * AST types        - make proc signatures in CPS code more intentional
# * AST procs        - contain the gotchas and peculiarities of Nim AST
# * Normalized types - codify the pre/post conditions of CPS code
# * Normalized procs - ensure invariants by centralizing the AST operations
#
# TODO
# * move away from assert where it makes sense
# * make templates to ease some of the type type boilerplate

func isEmpty*(n: NimNode): bool =
  ## `true` if the node `n` is Empty
  result = not n.isNil and n.kind == nnkEmpty

# These are the regular AST types, but specialized
type
  SymNode* = distinct NimNode
  IdentNode* = distinct NimNode
  NameNode* = distinct NimNode
  AnyNameNode* = SymNode | IdentNode | NameNode

  VarLetSection* = distinct NimNode
    ## a var or let section with one or more declarations in the section
  VarTupleOrIdentDefs = distinct NimNode
    ## Var and Let Sections can have VarTuple (destructuring) or IdentDefs
  IdentDefs* = distinct NimNode
    ## one or more identifiers and their definition
  VarTuple* = distinct NimNode
    ## typically a destructuring tuple
  AnyVarTupleOrIdentDefs = VarTupleOrIdentDefs | VarTuple | IdentDefs
    ## useful when we want a sub-type like relation

  StmtList* = distinct NimNode

  # HiddenAddr = distinct NimNode
  # HiddenDeref = distinct NimNode
  HiddenAddrDeref* = distinct NimNode

  ProcDef* = distinct NimNode
  FormalParams* = distinct NimNode

  Call* = distinct NimNode
  Conv* = distinct NimNode
    ## nnkConv node, only valid when generated by sem
  HiddenCallConv* = distinct NimNode
    ## nnkHiddenCallConv

  CallLike* = Call

  ReturnStmt* = distinct NimNode

  # Handling sub-sets of nodes and their invalid variety
  DistinctNimNode = AnyVarTupleOrIdentDefs | VarLetSection | ReturnStmt | HiddenAddrDeref | ProcDef

  Maybe*[T: DistinctNimNode] = object
    n*: T

  # Enums representing smaller sub-sets
  VarLetSectionChildKind* {.pure.} = enum
    nnkIdentDefs = nnkIdentDefs,
    nnkVarTuple = nnkVarTuple,
    invalid

  # Utility Types
  Mapper*[T = NimNode] = proc(n: NimNode): T

# Converters - because plastering `.NimNode` makes everyone sad

template converterFor(t: typedesc) =
  converter `c t ToNimNode`*(n: `t`): NimNode = n.NimNode

converterFor(IdentDefs)
converterFor(StmtList)
converterFor(Call)
converterFor(FormalParams)
converterFor(ReturnStmt)
converterFor(ProcDef)
converterFor(NameNode)

# fn-Error

proc errorAst*(s: string, info: NimNode = nil): NimNode =
  ## produce {.error: s.} in order to embed errors in the ast
  ##
  ## optionally take a node to set the error line information
  result = nnkPragma.newTree:
    ident"error".newColonExpr: newLit s
  if not info.isNil:
    result[0].copyLineInfo info

proc errorAst*(n: NimNode; s = "creepy ast"): NimNode =
  ## embed an error with a message, the line info is copied from the node
  ## too
  # TODO: we might no longer need this now that the other version can
  #       get the line info
  errorAst(s & ":\n" & treeRepr(n) & "\n", n)

proc errorAst*[T:DistinctNimNode](n: T; s = "creepy ast"): NimNode =
  errorAst(n.NimNode, s)

proc errorAst*[T:DistinctNimNode](n: Maybe[T]; s = "creepy ast"): NimNode =
  errorAst(n.n.NimNode, s)

# fn-Maybe

func baseKind*(n: Maybe): NimNodeKind =
  n.n.NimNode.kind

# fn-NameNode

proc baseKind(n: NameNode): NimNodeKind =
  n.NimNode.kind

# fn-IdentNode

proc newIdentNode(i: string, infoOf: NimNode): IdentNode =
  result = ident(i).IdentNode
  result.NimNode.copyLineInfo infoOf

# fn-SymNode

proc desym(n: NameNode): NameNode =
  result =
    case n.baseKind
    of nnkSym:
      newIdentNode(repr n, infoOf = n.NimNode).NameNode
    else:
      n

# fn-stmtList

proc newStmtList2*(): StmtList =
  ## creates a new `nnkStmtList`, but
  newStmtList().StmtList

proc add*(n: StmtList, c: DistinctNimNode): StmtList {.discardable.} =
  ## add to the StmtList and return it for chaining
  n.NimNode.add(c.NimNode).StmtList

# this overload has to come after the `DistinctNimNode` one or things break
proc add*(n: StmtList, c: NimNode): StmtList {.borrow, discardable.}

# fn-IdentDefs

func hasNoExplicitInitValue*(i: IdentDefs): bool =
  i.len == 2

func hasNoExplicitType*(i: IdentDefs): bool =
  i[^2].isEmpty

proc ensureExplicitType*(i: IdentDefs) =
  ## add an explicit type symbol
  if i.hasNoExplicitType:
    i[^2] = getTypeInst i[^1]

proc definition*(i: IdentDefs): NimNode =
  ## gets the rhs or value
  i[^1]

proc `definition=`*(i: IdentDefs, v: NimNode) =
  ## sets the rhs or value
  i[^1] = v

proc definesMany*(i: IdentDefs): bool =
  ## does the ident def define multiple identifiers, eg: `var a, b, c = 3`
  i.len > 3

iterator itemsDefined*(i: IdentDefs): IdentDefs =
  ## an IdentDef per define or a copy of itself
  if i.definesMany:
    for child in i[0 .. ^3]: # last two nodes are the type and rhs
      yield newIdentDefs(child, copyNimNode(i[^2]), copyNimNode(i[^1])).IdentDefs
  else:
    yield copy(i).IdentDefs

proc get*(n: Maybe[IdentDefs]): IdentDefs =
  doAssert n.baseKind == nnkIdentDefs
  n.n

proc asIdentDefs*(n: NimNode): Maybe[IdentDefs] =
  result = Maybe[IdentDefs](n: n.IdentDefs)

# fn-VarTupleOrIdentDefs

func kind*(n: Maybe[VarTupleOrIdentDefs]): VarLetSectionChildKind =
  case n.baseKind
  of nnkVarTuple: VarletSectionChildKind.nnkVarTuple
  of nnkIdentDefs: VarLetSectionChildKind.nnkIdentDefs
  else: VarLetSectionChildKind.invalid

func asVarTupleOrIdentDefs(n: NimNode): Maybe[VarTupleOrIdentDefs] =
  result = Maybe[VarTupleOrIdentDefs](n: n.VarTupleOrIdentDefs)

func get*(n: Maybe[VarTupleOrIdentDefs]): VarTupleOrIdentDefs =
  doAssert n.baseKind in {nnkVarTuple, nnkIdentDefs}
  result = n.n

func get*[T: VarTuple | IdentDefs](n: Maybe[VarTupleOrIdentDefs], _: typedesc[T]): T =
  doAssert n.baseKind == (when T is IdentDefs: nnkIdentDefs else: nnkVarTuple)
  result = n.n.T

# fn-VarLetSection

func baseKind*(n: VarLetSection): NimNodeKind =
  n.NimNode.kind

iterator items*(n: VarLetSection): Maybe[VarTupleOrIdentDefs] =
  for child in n.NimNode.items():
    yield Maybe(child.asVarTupleOrIdentDefs)

proc add*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection =
  n.NimNode.add(c.NimNode)
  n

proc newSingleChildSection*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection =
  result = newNimNode(n.baseKind, n.NimNode).VarLetSection
  return result.add(c)

proc asVarLetSection*(n: NimNode): VarLetSection =
  # XXX: move away from assert, maybe via Maybe
  doAssert n.kind in {nnkVarSection, nnkLetSection}
  result = n.VarLetSection

# fn-HiddenAddrDeref

func target*(n: HiddenAddrDeref): NimNode =
  n.NimNode[0]

func get*(n: Maybe[HiddenAddrDeref]): HiddenAddrDeref =
  doAssert n.baseKind in {nnkHiddenAddr, nnkHiddenDeref}
  result = n.n

func asHiddenAddrDeref*(n: NimNode): Maybe[HiddenAddrDeref] =
  result = Maybe[HiddenAddrDeref](n: n.HiddenAddrDeref)

# fn-FormalParams

proc add*(n: FormalParams, p: NimNode): FormalParams {.borrow, discardable.}

proc newFormalParams*(infoOf: NimNode, retParam: NimNode): FormalParams =
  result = newNimNode(nnkFormalParams, infoOf).FormalParams
  result.add retParam

iterator formalArgParams*(n: FormalParams): NimNode =
  for a in n[1 .. ^1]:
    yield a

proc returnParam*(n: FormalParams): NimNode =
  n[0]

# fn-ProcDef

proc expectProcDef*(n: NimNode): ProcDef =
  ## will be a ProcDef or use `expectKind` to error out
  result = n.ProcDef
  n.expectKind nnkProcDef

proc returnParam(n: ProcDef): NimNode =
  ## the return param or empty if void
  ## XXX: make this return a ReturnParam (Ident|Sym|Expr|Empty)
  n.NimNode.params[0]

proc `returnParam=`*(p: ProcDef, n: NimNode): NimNode {.discardable.} =
  ## set the return param
  p.NimNode.params[0] = n

proc isVoidReturn*(n: ProcDef): bool =
  ## is this a void func or proc?
  return n.returnParam.isEmpty

proc name*(n: ProcDef): NameNode {.borrow.}

proc `name=`*(p: ProcDef, n: AnyNameNode): ProcDef {.discardable.} =
  # compiler can't figure out the types in order to borrow it
  p.NimNode.name = n.NimNode
  p

proc params*(n: ProcDef): NimNode {.borrow.}

proc `params=`*(n: ProcDef, f: NimNode) {.borrow.}

proc body*(n: ProcDef): NimNode {.borrow.}

proc `body=`*(n: ProcDef, b: NimNode) {.borrow.}

proc addPragma*(n: ProcDef, p: NimNode): ProcDef {.discardable.} =
  ## add a pragma then return the ProcDef for chaining
  proc addPragma(n: ProcDef, p: NimNode) {.borrow.}
  n.addPragma p
  n

proc pruneTypes*(p: ProcDef) =
  ## prune some of the typed trees
  ## XXX: there should be a better description of this
  ## XXX: remove `NimNode`
  p.name = desym(p.name)
  while len(p.NimNode) > 7:
    p.NimNode.del(7)

proc clone*(n: ProcDef, body: NimNode = nil): ProcDef =
  ## create a copy of a typed proc which satisfies the compiler
  # XXX: rip out the `NimNode`
  result = (nnkProcDef.newTree(
    ident(repr n.name),           # repr to handle gensymbols
    newEmptyNode(),
    newEmptyNode(),
    n.params,
    newEmptyNode(),
    newEmptyNode(),
    if body == nil: copy n.body else: body)).ProcDef
  result.NimNode.copyLineInfo n.NimNode

# fn-Call

proc newCall2*(name: NimNode, infoOf: NimNode, arg: NimNode): Call =
  ## Create a new single arugment Call (nnkCall)
  ## XXX: rename to newCall once types are less ambiguous
  result = newNimNode(nnkCall, infoOf).Call
  result.NimNode.add name
  result.NimNode.add arg

# fn-Conv

proc name*(c: Conv): NimNode =
  # can't be borrowed as the macros impl can't pull the name
  c.NimNode[0]

proc arg*(c: Conv): NimNode =
  c.NimNode[1]

proc asConv*(n: NimNode): Conv =
  assert n.kind == nnkConv
  result = n.Conv

# fn-HiddenCallConv

proc expectHiddenCallConv*(n: NimNode): HiddenCallConv =
  ## will be a HiddenCallConv or use `expectKind` to error out
  result = n.HiddenCallConv
  n.expectKind nnkHiddenCallConv

proc toCall*(n: HiddenCallConv, mapper: Mapper): Call =
  ## unwraps the hidden conversion, mapping the children over
  result = nnkCall.newNimNode(n.NimNode).Call
  for child in n.NimNode.items:
    result.NimNode.add:
      mapper(child)

# fn-Calllike

proc isBinaryOrMore*(n: CallLike): bool =
  ## Takes at least one argument
  n.NimNode.len > 1

proc hasHiddenStdConv*(n: CallLike): bool =
  ## Has an immediate child with a standard conversion
  not n.NimNode.findChild(it.kind == nnkHiddenStdConv).isNil

proc copy*(n: CallLike): CallLike =
  proc copyNimNode(n: CallLike): CallLike {.borrow.}
  n.copyNimNode

# fn-ReturnStmt

proc copy*(n: ReturnStmt): ReturnStmt =
  copyNimNode(n.NimNode).ReturnStmt

# proc add*(n: ReturnStmt, c: NimNode): ReturnStmt {.borrow, discardable.}

proc isAssignment*(n: ReturnStmt): bool =
  n.NimNode[0].kind == nnkAsgn

proc expression*(n: ReturnStmt): NimNode =
  n.NimNode[0]

proc `expression=`*(n: ReturnStmt, r: NimNode) =
  if n.len == 0:
    n.add r
  else:
    n[0] = r

proc asReturnStmt*(n: NimNode): ReturnStmt =
  doAssert n.kind == nnkReturnStmt
  result = n.ReturnStmt
