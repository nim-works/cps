import std/macros
from std/typetraits import distinctBase

# Parts of this module:
# * distinct types representing specific variants of Nim AST (`NimNode`)
# * procs used to query, transform, etc on the above as conveniences
# * distinct types representing normalized/transformed variants of distinct AST
# * procs use to query, transform, etc on the normalized AST as conveniences
#
# Why each part:
# * AST types        - make proc signatures in CPS code more intentional
# * AST procs        - contain the gotchas and peculiarities of Nim AST
# * Normalized types - codify the pre/post conditions of CPS code
# * Normalized procs - ensure invariants by centralizing the AST operations
#
# TODO
# * move away from assert where it makes sense
# * make templates to ease some of the type type boilerplate

func isEmpty*(n: NimNode): bool =
  ## `true` if the node `n` is Empty
  result = not n.isNil and n.kind == nnkEmpty

# These are the regular AST types, but specialized
type
  VarLetSection* = distinct NimNode
    ## a var or let section with one or more declarations in the section
  VarTupleOrIdentDefs = distinct NimNode
    ## Var and Let Sections can have VarTuple (destructuring) or IdentDefs
  IdentDefs* = distinct NimNode
    ## one or more identifiers and their definition
  VarTuple* = distinct NimNode
    ## typically a destructuring tuple
  AnyVarTupleOrIdentDefs = VarTupleOrIdentDefs | VarTuple | IdentDefs
    ## useful when we want a sub-type like relation

  Conv* = distinct NimNode
    ## nnkConv node, only valid when generated by sem
  Call* = distinct NimNode

  ReturnStmt* = distinct NimNode

  # Handling sub-sets of nodes and their invalid variety
  DistinctNimNode = AnyVarTupleOrIdentDefs

  Maybe*[T: DistinctNimNode] = object
    n*: T

  # Enums representing smaller sub-sets
  VarLetSectionChildKind* {.pure.} = enum
    nnkIdentDefs = nnkIdentDefs,
    nnkVarTuple = nnkVarTuple,
    invalid

# fn-Error

proc errorAst*(s: string, info: NimNode = nil): NimNode =
  ## produce {.error: s.} in order to embed errors in the ast
  ##
  ## optionally take a node to set the error line information
  result = nnkPragma.newTree:
    ident"error".newColonExpr: newLit s
  if not info.isNil:
    result[0].copyLineInfo info

proc errorAst*(n: NimNode; s = "creepy ast"): NimNode {.inline.} =
  ## embed an error with a message, the line info is copied from the node
  ## too
  # TODO: we might no longer need this now that the other version can
  #       get the line info
  errorAst(s & ":\n" & treeRepr(n) & "\n", n)

proc errorAst*[T:DistinctNimNode](n: T; s = "creepy ast"): NimNode {.inline.} =
  errorAst(n.NimNode, s)

proc errorAst*[T:DistinctNimNode](n: Maybe[T]; s = "creepy ast"): NimNode {.inline.} =
  errorAst(n.n.NimNode, s)

# fn-Maybe

func baseKind*(n: Maybe): NimNodeKind {.inline.} =
  n.n.NimNode.kind

# fn-IdentDefs

func hasNoExplicitInitValue*(i: IdentDefs): bool {.inline.} =
  i.NimNode.len == 2

func hasNoExplicitType*(i: IdentDefs): bool {.inline.} =
  i.NimNode[1].isEmpty

proc ensureExplicitType*(i: IdentDefs) {.inline.} =
  ## add an explicit type symbol
  if i.hasNoExplicitType:
    i.NimNode[1] = getTypeInst i.NimNode[2]

proc definition*(i: IdentDefs): NimNode {.inline.} =
  i.NimNode[2]

proc `definition=`*(i: IdentDefs, v: NimNode) {.inline.} =
  i.NimNode[2] = v

proc get*(n: Maybe[IdentDefs]): IdentDefs {.inline.} =
  doAssert n.baseKind == nnkIdentDefs
  n.n

proc asIdentDefs*(n: NimNode): Maybe[IdentDefs] {.inline.} =
  result = Maybe[IdentDefs](n: n.IdentDefs)

# fn-VarTupleOrIdentDefs

func kind*(n: Maybe[VarTupleOrIdentDefs]): VarLetSectionChildKind {.inline.} =
  case n.baseKind
  of nnkVarTuple: VarletSectionChildKind.nnkVarTuple
  of nnkIdentDefs: VarLetSectionChildKind.nnkIdentDefs
  else: VarLetSectionChildKind.invalid

func asVarTupleOrIdentDefs(n: NimNode): Maybe[VarTupleOrIdentDefs] {.inline.} =
  result = Maybe[VarTupleOrIdentDefs](n: n.VarTupleOrIdentDefs)

func get*(n: Maybe[VarTupleOrIdentDefs]): VarTupleOrIdentDefs {.inline.} =
  doAssert n.baseKind in {nnkVarTuple, nnkIdentDefs}
  result = n.n

func get*[T: VarTuple | IdentDefs](n: Maybe[VarTupleOrIdentDefs], _: typedesc[T]): T {.inline.} =
  doAssert n.baseKind == (when T is IdentDefs: nnkIdentDefs else: nnkVarTuple)
  result = n.n.T

# fn-VarLetSection

func baseKind*(n: VarLetSection): NimNodeKind {.inline.} =
  n.NimNode.kind

iterator items*(n: VarLetSection): Maybe[VarTupleOrIdentDefs] {.inline.} =
  for child in n.NimNode.items():
    yield Maybe(child.asVarTupleOrIdentDefs)

proc add*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection {.inline.} =
  n.NimNode.add(c.NimNode)
  n

proc newSingleChildSection*(n: VarLetSection, c: AnyVarTupleOrIdentDefs): VarLetSection =
  result = newNimNode(n.baseKind, n.NimNode).VarLetSection
  return result.add(c)

proc asVarLetSection*(n: NimNode): VarLetSection {.inline.} =
  # XXX: move away from assert, maybe via Maybe
  doAssert n.kind in {nnkVarSection, nnkLetSection}
  result = n.VarLetSection

# fn-Conv

proc name*(c: Conv, n: NimNode): NimNode {.inline.} =
  c.NimNode[0]

proc arg*(c: Conv, n: NimNode): NimNode {.inline.} =
  c.NimNode[1]

proc asConv*(n: NimNode): Conv {.inline.} =
  assert n.kind == nnkConv
  result = n.Conv

# fn-ReturnStmt

proc isAssignment*(n: ReturnStmt): bool {.inline.} =
  n.NimNode[0].kind == nnkAsgn

proc asReturnStmt*(n: NimNode): ReturnStmt {.inline.} =
  assert n.kind == nnkReturnStmt
  result = n.ReturnStmt

when false:
  # These are the Normalized AST types
  type
    SingularVarLetSection = distinct VarLetSection
      ## a var or let section guaranteed to only contain one var or let
    NormalizedIdentDefs = distinct IdentDefs
      ## a normalized identifier(s) definition

  proc normalizingRewrites*(n: NimNode): NimNode
  ## Rewrite AST into a safe form for manipulation

  proc normalizeIdentDefs(idents: IdentDefs): NormalizedIdentDefs =
    ## Rewrite an identDefs to ensure it has three children.
    if idents.hasNoExplicitInitValue:
      idents.add newEmptyNode()
    else:
      idents.ensureExplicitType()
    ident.definition = normalizingRewrites ident.definnition
    result = idents

  proc normalizedVarLetSections(s: VarSection): seq[SingularVarLetSection] =
    ## Rewrite a var|let section of multiple identDefs
    ## into multiple such sections with well-formed identDefs
    for child in s.items:
      case child.kind:
      of nnkVarTuple:
        # a new section with a single rewritten identdefs within
        # for each symbol in the VarTuple statement
        for i, value in child.last.pairs:
          result.add:
            newNimNode(s.kind, s).add:
              normalizeIdentDefs:
                newIdentDefs(child[i], getType(value), value)
      of nnkIdentDefs:
        # a new section with a single rewritten identdefs within
        result.add:
          newNimNode(s.kind, n).add:
            normalizeIdentDefs(child)
      else:
        result.add:
          child.errorAst "unexpected"

  proc normalizeReturn(n: ReturnStmt): NormalizedReturnStmt =
    ## Inside procs, the compiler might produce an AST structure like this:
    ##
    ## ```
    ## ReturnStmt
    ##   Asgn
    ##     Sym "result"
    ##     Sym "continuation"
    ## ```
    ##
    ## for `return continuation`.
    ##
    ## This structure is not valid if modified.
    ##
    ## Rewrite this back to `return expr`.
    if n.isAssignment:
      result = copyNimNode(n)
      doAssert repr(n[0][0]) == "result", "unexpected AST"
      result.add:
        normalizingRewrites n[0][1]
    else:
      result = n

  proc normalizeConv(n: Conv): Call =
    ## Rewrite a nnkConv (which is a specialized nnkCall) back into nnkCall.
    ## This is because nnkConv nodes are only valid if produced by sem.
    result = newNimNode(nnkCall, n)
    result.add:
      normalizingRewrites n[0]
    result.add:
      normalizingRewrites n[1]

  proc normalizingRewrites(n: NimNode): NimNode =
    # see forward declaration for docs

    case n.kind
    of nnkIdentDefs:
      normalizeIdentDefs n.asIdentDefs
    of nnkLetSection, nnkVarSection:
      normalizedVarLetSections n.asVarLetSection
    of nnkHiddenAddr, nnkHiddenDeref:
      # Remove nnkHiddenAddr/Deref because they cause the carnac bug
      normalizingRewrites n[0]
    of nnkConv:
      normalizeConv n.asConv
    of nnkReturnStmt:
      normalizeReturn n.asReturnStmt
    of CallNodes:
      rewriteHidden n
    else:
      nil